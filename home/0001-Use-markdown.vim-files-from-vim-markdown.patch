From 2e36c014d50905409156bbd049ce0f363fa2b147 Mon Sep 17 00:00:00 2001
From: Even Brenden <evenbrenden@gmail.com>
Date: Fri, 6 May 2022 13:50:14 +0200
Subject: [PATCH 1/1] Use markdown.vim files from vim-markdown

From preservim/vim-markdown at 9068655.
---
 runtime/ftplugin/markdown.vim | 913 ++++++++++++++++++++++++++++++++--
 runtime/syntax/markdown.vim   | 317 ++++++------
 2 files changed, 1025 insertions(+), 205 deletions(-)

diff --git a/runtime/ftplugin/markdown.vim b/runtime/ftplugin/markdown.vim
index fc1d9e068..2fb8e582e 100644
--- a/runtime/ftplugin/markdown.vim
+++ b/runtime/ftplugin/markdown.vim
@@ -1,74 +1,879 @@
-" Vim filetype plugin
-" Language:		Markdown
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" Last Change:		2019 Dec 05
+"TODO print messages when on visual mode. I only see VISUAL, not the messages.
 
-if exists("b:did_ftplugin")
-  finish
-endif
+" Function interface phylosophy:
+"
+" - functions take arbitrary line numbers as parameters.
+"    Current cursor line is only a suitable default parameter.
+"
+" - only functions that bind directly to user actions:
+"
+"    - print error messages.
+"       All intermediate functions limit themselves return `0` to indicate an error.
+"
+"    - move the cursor. All other functions do not move the cursor.
+"
+" This is how you should view headers for the header mappings:
+"
+"   |BUFFER
+"   |
+"   |Outside any header
+"   |
+" a-+# a
+"   |
+"   |Inside a
+"   |
+" a-+
+" b-+## b
+"   |
+"   |inside b
+"   |
+" b-+
+" c-+### c
+"   |
+"   |Inside c
+"   |
+" c-+
+" d-|# d
+"   |
+"   |Inside d
+"   |
+" d-+
+" e-|e
+"   |====
+"   |
+"   |Inside e
+"   |
+" e-+
 
-runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
+" For each level, contains the regexp that matches at that level only.
+"
+let s:levelRegexpDict = {
+    \ 1: '\v^(#[^#]@=|.+\n\=+$)',
+    \ 2: '\v^(##[^#]@=|.+\n-+$)',
+    \ 3: '\v^###[^#]@=',
+    \ 4: '\v^####[^#]@=',
+    \ 5: '\v^#####[^#]@=',
+    \ 6: '\v^######[^#]@='
+\ }
 
-setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
-setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
-setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:
+" Maches any header level of any type.
+"
+" This could be deduced from `s:levelRegexpDict`, but it is more
+" efficient to have a single regexp for this.
+"
+let s:headersRegexp = '\v^(#|.+\n(\=+|-+)$)'
 
-if exists('b:undo_ftplugin')
-  let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
-else
-  let b:undo_ftplugin = "setl cms< com< fo< flp<"
-endif
+" Returns the line number of the first header before `line`, called the
+" current header.
+"
+" If there is no current header, return `0`.
+"
+" @param a:1 The line to look the header of. Default value: `getpos('.')`.
+"
+function! s:GetHeaderLineNum(...)
+    if a:0 == 0
+        let l:l = line('.')
+    else
+        let l:l = a:1
+    endif
+    while(l:l > 0)
+        if join(getline(l:l, l:l + 1), "\n") =~ s:headersRegexp
+            return l:l
+        endif
+        let l:l -= 1
+    endwhile
+    return 0
+endfunction
+
+" -  if inside a header goes to it.
+"    Return its line number.
+"
+" -  if on top level outside any headers,
+"    print a warning
+"    Return `0`.
+"
+function! s:MoveToCurHeader()
+    let l:lineNum = s:GetHeaderLineNum()
+    if l:lineNum !=# 0
+        call cursor(l:lineNum, 1)
+    else
+        echo 'outside any header'
+        "normal! gg
+    endif
+    return l:lineNum
+endfunction
+
+" Move cursor to next header of any level.
+"
+" If there are no more headers, print a warning.
+"
+function! s:MoveToNextHeader()
+    if search(s:headersRegexp, 'W') == 0
+        "normal! G
+        echo 'no next header'
+    endif
+endfunction
+
+" Move cursor to previous header (before current) of any level.
+"
+" If it does not exist, print a warning.
+"
+function! s:MoveToPreviousHeader()
+    let l:curHeaderLineNumber = s:GetHeaderLineNum()
+    let l:noPreviousHeader = 0
+    if l:curHeaderLineNumber <= 1
+        let l:noPreviousHeader = 1
+    else
+        let l:previousHeaderLineNumber = s:GetHeaderLineNum(l:curHeaderLineNumber - 1)
+        if l:previousHeaderLineNumber == 0
+            let l:noPreviousHeader = 1
+        else
+            call cursor(l:previousHeaderLineNumber, 1)
+        endif
+    endif
+    if l:noPreviousHeader
+        echo 'no previous header'
+    endif
+endfunction
+
+" - if line is inside a header, return the header level (h1 -> 1, h2 -> 2, etc.).
+"
+" - if line is at top level outside any headers, return `0`.
+"
+function! s:GetHeaderLevel(...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:linenum = s:GetHeaderLineNum(l:line)
+    if l:linenum !=# 0
+        return s:GetLevelOfHeaderAtLine(l:linenum)
+    else
+        return 0
+    endif
+endfunction
+
+" Return list of headers and their levels.
+"
+function! s:GetHeaderList()
+    let l:bufnr = bufnr('%')
+    let l:fenced_block = 0
+    let l:front_matter = 0
+    let l:header_list = []
+    let l:vim_markdown_frontmatter = get(g:, 'vim_markdown_frontmatter', 0)
+    for i in range(1, line('$'))
+        let l:lineraw = getline(i)
+        let l:l1 = getline(i+1)
+        let l:line = substitute(l:lineraw, '#', "\\\#", 'g')
+        " exclude lines in fenced code blocks
+        if l:line =~# '````*' || l:line =~# '\~\~\~\~*'
+            if l:fenced_block == 0
+                let l:fenced_block = 1
+            elseif l:fenced_block == 1
+                let l:fenced_block = 0
+            endif
+        " exclude lines in frontmatters
+        elseif l:vim_markdown_frontmatter == 1
+            if l:front_matter == 1
+                if l:line ==# '---'
+                    let l:front_matter = 0
+                endif
+            elseif i == 1
+                if l:line ==# '---'
+                    let l:front_matter = 1
+                endif
+            endif
+        endif
+        " match line against header regex
+        if join(getline(i, i + 1), "\n") =~# s:headersRegexp && l:line =~# '^\S'
+            let l:is_header = 1
+        else
+            let l:is_header = 0
+        endif
+        if l:is_header ==# 1 && l:fenced_block ==# 0 && l:front_matter ==# 0
+            " remove hashes from atx headers
+            if match(l:line, '^#') > -1
+                let l:line = substitute(l:line, '\v^#*[ ]*', '', '')
+                let l:line = substitute(l:line, '\v[ ]*#*$', '', '')
+            endif
+            " append line to list
+            let l:level = s:GetHeaderLevel(i)
+            let l:item = {'level': l:level, 'text': l:line, 'lnum': i, 'bufnr': bufnr}
+            let l:header_list = l:header_list + [l:item]
+        endif
+    endfor
+    return l:header_list
+endfunction
+
+" Returns the level of the header at the given line.
+"
+" If there is no header at the given line, returns `0`.
+"
+function! s:GetLevelOfHeaderAtLine(linenum)
+    let l:lines = join(getline(a:linenum, a:linenum + 1), "\n")
+    for l:key in keys(s:levelRegexpDict)
+        if l:lines =~ get(s:levelRegexpDict, l:key)
+            return l:key
+        endif
+    endfor
+    return 0
+endfunction
+
+" Move cursor to parent header of the current header.
+"
+" If it does not exit, print a warning and do nothing.
+"
+function! s:MoveToParentHeader()
+    let l:linenum = s:GetParentHeaderLineNumber()
+    if l:linenum != 0
+        call setpos("''", getpos('.'))
+        call cursor(l:linenum, 1)
+    else
+        echo 'no parent header'
+    endif
+endfunction
+
+" Return the line number of the parent header of line `line`.
+"
+" If it has no parent, return `0`.
+"
+function! s:GetParentHeaderLineNumber(...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:level = s:GetHeaderLevel(l:line)
+    if l:level > 1
+        let l:linenum = s:GetPreviousHeaderLineNumberAtLevel(l:level - 1, l:line)
+        return l:linenum
+    endif
+    return 0
+endfunction
+
+" Return the line number of the previous header of given level.
+" in relation to line `a:1`. If not given, `a:1 = getline()`
+"
+" `a:1` line is included, and this may return the current header.
+"
+" If none return 0.
+"
+function! s:GetNextHeaderLineNumberAtLevel(level, ...)
+    if a:0 < 1
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:l = l:line
+    while(l:l <= line('$'))
+        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
+            return l:l
+        endif
+        let l:l += 1
+    endwhile
+    return 0
+endfunction
+
+" Return the line number of the previous header of given level.
+" in relation to line `a:1`. If not given, `a:1 = getline()`
+"
+" `a:1` line is included, and this may return the current header.
+"
+" If none return 0.
+"
+function! s:GetPreviousHeaderLineNumberAtLevel(level, ...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:l = l:line
+    while(l:l > 0)
+        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
+            return l:l
+        endif
+        let l:l -= 1
+    endwhile
+    return 0
+endfunction
+
+" Move cursor to next sibling header.
+"
+" If there is no next siblings, print a warning and don't move.
+"
+function! s:MoveToNextSiblingHeader()
+    let l:curHeaderLineNumber = s:GetHeaderLineNum()
+    let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
+    let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
+    let l:nextHeaderSameLevelLineNumber = s:GetNextHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber + 1)
+    let l:noNextSibling = 0
+    if l:nextHeaderSameLevelLineNumber == 0
+        let l:noNextSibling = 1
+    else
+        let l:nextHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:nextHeaderSameLevelLineNumber)
+        if l:curHeaderParentLineNumber == l:nextHeaderSameLevelParentLineNumber
+            call cursor(l:nextHeaderSameLevelLineNumber, 1)
+        else
+            let l:noNextSibling = 1
+        endif
+    endif
+    if l:noNextSibling
+        echo 'no next sibling header'
+    endif
+endfunction
+
+" Move cursor to previous sibling header.
+"
+" If there is no previous siblings, print a warning and do nothing.
+"
+function! s:MoveToPreviousSiblingHeader()
+    let l:curHeaderLineNumber = s:GetHeaderLineNum()
+    let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
+    let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
+    let l:previousHeaderSameLevelLineNumber = s:GetPreviousHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber - 1)
+    let l:noPreviousSibling = 0
+    if l:previousHeaderSameLevelLineNumber == 0
+        let l:noPreviousSibling = 1
+    else
+        let l:previousHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:previousHeaderSameLevelLineNumber)
+        if l:curHeaderParentLineNumber == l:previousHeaderSameLevelParentLineNumber
+            call cursor(l:previousHeaderSameLevelLineNumber, 1)
+        else
+            let l:noPreviousSibling = 1
+        endif
+    endif
+    if l:noPreviousSibling
+        echo 'no previous sibling header'
+    endif
+endfunction
+
+function! s:Toc(...)
+    if a:0 > 0
+        let l:window_type = a:1
+    else
+        let l:window_type = 'vertical'
+    endif
+
+
+    let l:cursor_line = line('.')
+    let l:cursor_header = 0
+    let l:header_list = s:GetHeaderList()
+    let l:indented_header_list = []
+    if len(l:header_list) == 0
+        echom 'Toc: No headers.'
+        return
+    endif
+    let l:header_max_len = 0
+    let l:vim_markdown_toc_autofit = get(g:, 'vim_markdown_toc_autofit', 0)
+    for h in l:header_list
+        " set header number of the cursor position
+        if l:cursor_header == 0
+            let l:header_line = h.lnum
+            if l:header_line == l:cursor_line
+                let l:cursor_header = index(l:header_list, h) + 1
+            elseif l:header_line > l:cursor_line
+                let l:cursor_header = index(l:header_list, h)
+            endif
+        endif
+        " indent header based on level
+        let l:text = repeat('  ', h.level-1) . h.text
+        " keep track of the longest header size (heading level + title)
+        let l:total_len = strdisplaywidth(l:text)
+        if l:total_len > l:header_max_len
+            let l:header_max_len = l:total_len
+        endif
+        " append indented line to list
+        let l:item = {'lnum': h.lnum, 'text': l:text, 'valid': 1, 'bufnr': h.bufnr, 'col': 1}
+        let l:indented_header_list = l:indented_header_list + [l:item]
+    endfor
+    call setloclist(0, l:indented_header_list)
+
+    if l:window_type ==# 'horizontal'
+        lopen
+    elseif l:window_type ==# 'vertical'
+        vertical lopen
+        " auto-fit toc window when possible to shrink it
+        if (&columns/2) > l:header_max_len && l:vim_markdown_toc_autofit == 1
+            " header_max_len + 1 space for first header + 3 spaces for line numbers
+            execute 'vertical resize ' . (l:header_max_len + 1 + 3)
+        else
+            execute 'vertical resize ' . (&columns/2)
+        endif
+    elseif l:window_type ==# 'tab'
+        tab lopen
+    else
+        lopen
+    endif
+    setlocal modifiable
+    for i in range(1, line('$'))
+        " this is the location-list data for the current item
+        let d = getloclist(0)[i-1]
+        call setline(i, d.text)
+    endfor
+    setlocal nomodified
+    setlocal nomodifiable
+    execute 'normal! ' . l:cursor_header . 'G'
+endfunction
+
+function! s:InsertToc(format, ...)
+    if a:0 > 0
+        if type(a:1) != type(0)
+            echohl WarningMsg
+            echomsg '[vim-markdown] Invalid argument, must be an integer >= 2.'
+            echohl None
+            return
+        endif
+        let l:max_level = a:1
+        if l:max_level < 2
+            echohl WarningMsg
+            echomsg '[vim-markdown] Maximum level cannot be smaller than 2.'
+            echohl None
+            return
+        endif
+    else
+        let l:max_level = 0
+    endif
 
-function! s:NotCodeBlock(lnum) abort
-  return synIDattr(synID(v:lnum, 1, 1), 'name') !=# 'markdownCode'
+    let l:toc = []
+    let l:header_list = s:GetHeaderList()
+    if len(l:header_list) == 0
+        echom 'InsertToc: No headers.'
+        return
+    endif
+
+    if a:format ==# 'numbers'
+        let l:h2_count = 0
+        for header in l:header_list
+            if header.level == 2
+                let l:h2_count += 1
+            endif
+        endfor
+        let l:max_h2_number_len = strlen(string(l:h2_count))
+    else
+        let l:max_h2_number_len = 0
+    endif
+
+    let l:h2_count = 0
+    for header in l:header_list
+        let l:level = header.level
+        if l:level == 1
+            " skip level-1 headers
+            continue
+        elseif l:max_level != 0 && l:level > l:max_level
+            " skip unwanted levels
+            continue
+        elseif l:level == 2
+            " list of level-2 headers can be bullets or numbers
+            if a:format ==# 'bullets'
+                let l:indent = ''
+                let l:marker = '* '
+            else
+                let l:h2_count += 1
+                let l:number_len = strlen(string(l:h2_count))
+                let l:indent = repeat(' ', l:max_h2_number_len - l:number_len)
+                let l:marker = l:h2_count . '. '
+            endif
+        else
+            let l:indent = repeat(' ', l:max_h2_number_len + 2 * (l:level - 2))
+            let l:marker = '* '
+        endif
+        let l:text = '[' . header.text . ']'
+        let l:link = '(#' . substitute(tolower(header.text), '\v[ ]+', '-', 'g') . ')'
+        let l:line = l:indent . l:marker . l:text . l:link
+        let l:toc = l:toc + [l:line]
+    endfor
+
+    call append(line('.'), l:toc)
+endfunction
+
+" Convert Setex headers in range `line1 .. line2` to Atx.
+"
+" Return the number of conversions.
+"
+function! s:SetexToAtx(line1, line2)
+    let l:originalNumLines = line('$')
+    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n\=+$/# \1/'
+    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n-+$/## \1/'
+    return l:originalNumLines - line('$')
 endfunction
 
-function! MarkdownFold() abort
-  let line = getline(v:lnum)
+" If `a:1` is 0, decrease the level of all headers in range `line1 .. line2`.
+"
+" Otherwise, increase the level. `a:1` defaults to `0`.
+"
+function! s:HeaderDecrease(line1, line2, ...)
+    if a:0 > 0
+        let l:increase = a:1
+    else
+        let l:increase = 0
+    endif
+    if l:increase
+        let l:forbiddenLevel = 6
+        let l:replaceLevels = [5, 1]
+        let l:levelDelta = 1
+    else
+        let l:forbiddenLevel = 1
+        let l:replaceLevels = [2, 6]
+        let l:levelDelta = -1
+    endif
+    for l:line in range(a:line1, a:line2)
+        if join(getline(l:line, l:line + 1), "\n") =~ s:levelRegexpDict[l:forbiddenLevel]
+            echomsg 'There is an h' . l:forbiddenLevel . ' at line ' . l:line . '. Aborting.'
+            return
+        endif
+    endfor
+    let l:numSubstitutions = s:SetexToAtx(a:line1, a:line2)
+    let l:flags = (&gdefault ? '' : 'g')
+    for l:level in range(replaceLevels[0], replaceLevels[1], -l:levelDelta)
+        execute 'silent! ' . a:line1 . ',' . (a:line2 - l:numSubstitutions) . 'substitute/' . s:levelRegexpDict[l:level] . '/' . repeat('#', l:level + l:levelDelta) . '/' . l:flags
+    endfor
+endfunction
 
-  if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
-    return ">" . match(line, ' ')
-  endif
+" Format table under cursor.
+"
+" Depends on Tabularize.
+"
+function! s:TableFormat()
+    let l:pos = getpos('.')
+    normal! {
+    " Search instead of `normal! j` because of the table at beginning of file edge case.
+    call search('|')
+    normal! j
+    " Remove everything that is not a pipe, colon or hyphen next to a colon othewise
+    " well formated tables would grow because of addition of 2 spaces on the separator
+    " line by Tabularize /|.
+    let l:flags = (&gdefault ? '' : 'g')
+    execute 's/\(:\@<!-:\@!\|[^|:-]\)//e' . l:flags
+    execute 's/--/-/e' . l:flags
+    Tabularize /|
+    " Move colons for alignment to left or right side of the cell.
+    execute 's/:\( \+\)|/\1:|/e' . l:flags
+    execute 's/|\( \+\):/|:\1/e' . l:flags
+    execute 's/|:\?\zs[ -]\+\ze:\?|/\=repeat("-", len(submatch(0)))/' . l:flags
+    call setpos('.', l:pos)
+endfunction
 
-  let nextline = getline(v:lnum + 1)
-  if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
-    return ">1"
-  endif
+" Wrapper to do move commands in visual mode.
+"
+function! s:VisMove(f)
+    norm! gv
+    call function(a:f)()
+endfunction
 
-  if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
-    return ">2"
-  endif
+" Map in both normal and visual modes.
+"
+function! s:MapNormVis(rhs,lhs)
+    execute 'nn <buffer><silent> ' . a:rhs . ' :call ' . a:lhs . '()<cr>'
+    execute 'vn <buffer><silent> ' . a:rhs . ' <esc>:call <sid>VisMove(''' . a:lhs . ''')<cr>'
+endfunction
 
-  return "="
+" Parameters:
+"
+" - step +1 for right, -1 for left
+"
+" TODO: multiple lines.
+"
+function! s:FindCornerOfSyntax(lnum, col, step)
+    let l:col = a:col
+    let l:syn = synIDattr(synID(a:lnum, l:col, 1), 'name')
+    while synIDattr(synID(a:lnum, l:col, 1), 'name') ==# l:syn
+        let l:col += a:step
+    endwhile
+    return l:col - a:step
 endfunction
 
-function! s:HashIndent(lnum) abort
-  let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
-  if len(hash_header)
-    return hash_header
-  else
-    let nextline = getline(a:lnum + 1)
-    if nextline =~# '^=\+\s*$'
-      return '#'
-    elseif nextline =~# '^-\+\s*$'
-      return '##'
+" Return the next position of the given syntax name,
+" inclusive on the given position.
+"
+" TODO: multiple lines
+"
+function! s:FindNextSyntax(lnum, col, name)
+    let l:col = a:col
+    let l:step = 1
+    while synIDattr(synID(a:lnum, l:col, 1), 'name') !=# a:name
+        let l:col += l:step
+    endwhile
+    return [a:lnum, l:col]
+endfunction
+
+function! s:FindCornersOfSyntax(lnum, col)
+    return [<sid>FindLeftOfSyntax(a:lnum, a:col), <sid>FindRightOfSyntax(a:lnum, a:col)]
+endfunction
+
+function! s:FindRightOfSyntax(lnum, col)
+    return <sid>FindCornerOfSyntax(a:lnum, a:col, 1)
+endfunction
+
+function! s:FindLeftOfSyntax(lnum, col)
+    return <sid>FindCornerOfSyntax(a:lnum, a:col, -1)
+endfunction
+
+" Returns:
+"
+" - a string with the the URL for the link under the cursor
+" - an empty string if the cursor is not on a link
+"
+" TODO
+"
+" - multiline support
+" - give an error if the separator does is not on a link
+"
+function! s:Markdown_GetUrlForPosition(lnum, col)
+    let l:lnum = a:lnum
+    let l:col = a:col
+    let l:syn = synIDattr(synID(l:lnum, l:col, 1), 'name')
+
+    if l:syn ==# 'mkdInlineURL' || l:syn ==# 'mkdURL' || l:syn ==# 'mkdLinkDefTarget'
+        " Do nothing.
+    elseif l:syn ==# 'mkdLink'
+        let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
+        let l:syn = 'mkdURL'
+    elseif l:syn ==# 'mkdDelimiter'
+        let l:line = getline(l:lnum)
+        let l:char = l:line[col - 1]
+        if l:char ==# '<'
+            let l:col += 1
+        elseif l:char ==# '>' || l:char ==# ')'
+            let l:col -= 1
+        elseif l:char ==# '[' || l:char ==# ']' || l:char ==# '('
+            let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
+        else
+            return ''
+        endif
+    else
+        return ''
+    endif
+
+    let [l:left, l:right] = <sid>FindCornersOfSyntax(l:lnum, l:col)
+    return getline(l:lnum)[l:left - 1 : l:right - 1]
+endfunction
+
+" Front end for GetUrlForPosition.
+"
+function! s:OpenUrlUnderCursor()
+    let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
+    if l:url !=# ''
+        call s:VersionAwareNetrwBrowseX(l:url)
+    else
+        echomsg 'The cursor is not on a link.'
     endif
-  endif
 endfunction
 
-function! MarkdownFoldText() abort
-  let hash_indent = s:HashIndent(v:foldstart)
-  let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
-  let foldsize = (v:foldend - v:foldstart + 1)
-  let linecount = '['.foldsize.' lines]'
-  return hash_indent.' '.title.' '.linecount
+" We need a definition guard because we invoke 'edit' which will reload this
+" script while this function is running. We must not replace it.
+if !exists('*s:EditUrlUnderCursor')
+    function s:EditUrlUnderCursor()
+        let l:editmethod = ''
+        " determine how to open the linked file (split, tab, etc)
+        if exists('g:vim_markdown_edit_url_in')
+          if g:vim_markdown_edit_url_in ==# 'tab'
+            let l:editmethod = 'tabnew'
+          elseif g:vim_markdown_edit_url_in ==# 'vsplit'
+            let l:editmethod = 'vsp'
+          elseif g:vim_markdown_edit_url_in ==# 'hsplit'
+            let l:editmethod = 'sp'
+          else
+            let l:editmethod = 'edit'
+          endif
+        else
+          " default to current buffer
+          let l:editmethod = 'edit'
+        endif
+        let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
+        if l:url !=# ''
+            if get(g:, 'vim_markdown_autowrite', 0)
+                write
+            endif
+            let l:anchor = ''
+            if get(g:, 'vim_markdown_follow_anchor', 0)
+                let l:parts = split(l:url, '#', 1)
+                if len(l:parts) == 2
+                    let [l:url, l:anchor] = parts
+                    let l:anchorexpr = get(g:, 'vim_markdown_anchorexpr', '')
+                    if l:anchorexpr !=# ''
+                        let l:anchor = eval(substitute(
+                            \ l:anchorexpr, 'v:anchor',
+                            \ escape('"'.l:anchor.'"', '"'), ''))
+                    endif
+                endif
+            endif
+            if l:url !=# ''
+                let l:ext = ''
+                if get(g:, 'vim_markdown_no_extensions_in_markdown', 0)
+                    " use another file extension if preferred
+                    if exists('g:vim_markdown_auto_extension_ext')
+                        let l:ext = '.'.g:vim_markdown_auto_extension_ext
+                    else
+                        let l:ext = '.md'
+                    endif
+                endif
+                let l:url = fnameescape(fnamemodify(expand('%:h').'/'.l:url.l:ext, ':.'))
+                execute l:editmethod l:url
+            endif
+            if l:anchor !=# ''
+                silent! execute '/'.l:anchor
+            endif
+        else
+            execute l:editmethod . ' <cfile>'
+        endif
+    endfunction
+endif
+
+function! s:VersionAwareNetrwBrowseX(url)
+    if has('patch-7.4.567')
+        call netrw#BrowseX(a:url, 0)
+    else
+        call netrw#NetrwBrowseX(a:url, 0)
+    endif
+endf
+
+function! s:MapNotHasmapto(lhs, rhs)
+    if !hasmapto('<Plug>' . a:rhs)
+        execute 'nmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
+        execute 'vmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
+    endif
 endfunction
 
-if has("folding") && exists("g:markdown_folding")
-  setlocal foldexpr=MarkdownFold()
-  setlocal foldmethod=expr
-  setlocal foldtext=MarkdownFoldText()
-  let b:undo_ftplugin .= " foldexpr< foldmethod< foldtext<"
+call <sid>MapNormVis('<Plug>Markdown_MoveToNextHeader', '<sid>MoveToNextHeader')
+call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousHeader', '<sid>MoveToPreviousHeader')
+call <sid>MapNormVis('<Plug>Markdown_MoveToNextSiblingHeader', '<sid>MoveToNextSiblingHeader')
+call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousSiblingHeader', '<sid>MoveToPreviousSiblingHeader')
+call <sid>MapNormVis('<Plug>Markdown_MoveToParentHeader', '<sid>MoveToParentHeader')
+call <sid>MapNormVis('<Plug>Markdown_MoveToCurHeader', '<sid>MoveToCurHeader')
+nnoremap <Plug>Markdown_OpenUrlUnderCursor :call <sid>OpenUrlUnderCursor()<cr>
+nnoremap <Plug>Markdown_EditUrlUnderCursor :call <sid>EditUrlUnderCursor()<cr>
+
+if !get(g:, 'vim_markdown_no_default_key_mappings', 0)
+    call <sid>MapNotHasmapto(']]', 'Markdown_MoveToNextHeader')
+    call <sid>MapNotHasmapto('[[', 'Markdown_MoveToPreviousHeader')
+    call <sid>MapNotHasmapto('][', 'Markdown_MoveToNextSiblingHeader')
+    call <sid>MapNotHasmapto('[]', 'Markdown_MoveToPreviousSiblingHeader')
+    call <sid>MapNotHasmapto(']u', 'Markdown_MoveToParentHeader')
+    call <sid>MapNotHasmapto(']h', 'Markdown_MoveToCurHeader')
+    call <sid>MapNotHasmapto('gx', 'Markdown_OpenUrlUnderCursor')
+    call <sid>MapNotHasmapto('ge', 'Markdown_EditUrlUnderCursor')
+endif
+
+command! -buffer -range=% HeaderDecrease call s:HeaderDecrease(<line1>, <line2>)
+command! -buffer -range=% HeaderIncrease call s:HeaderDecrease(<line1>, <line2>, 1)
+command! -buffer -range=% SetexToAtx call s:SetexToAtx(<line1>, <line2>)
+command! -buffer TableFormat call s:TableFormat()
+command! -buffer Toc call s:Toc()
+command! -buffer Toch call s:Toc('horizontal')
+command! -buffer Tocv call s:Toc('vertical')
+command! -buffer Toct call s:Toc('tab')
+command! -buffer -nargs=? InsertToc call s:InsertToc('bullets', <args>)
+command! -buffer -nargs=? InsertNToc call s:InsertToc('numbers', <args>)
+
+" Heavily based on vim-notes - http://peterodding.com/code/vim/notes/
+if exists('g:vim_markdown_fenced_languages')
+    let s:filetype_dict = {}
+    for s:filetype in g:vim_markdown_fenced_languages
+        let key = matchstr(s:filetype, '[^=]*')
+        let val = matchstr(s:filetype, '[^=]*$')
+        let s:filetype_dict[key] = val
+    endfor
+else
+    let s:filetype_dict = {
+        \ 'c++': 'cpp',
+        \ 'viml': 'vim',
+        \ 'bash': 'sh',
+        \ 'ini': 'dosini'
+    \ }
 endif
 
-" vim:set sw=2:
+function! s:MarkdownHighlightSources(force)
+    " Syntax highlight source code embedded in notes.
+    " Look for code blocks in the current file
+    let filetypes = {}
+    for line in getline(1, '$')
+        let ft = matchstr(line, '\(`\{3,}\|\~\{3,}\)\s*\zs[0-9A-Za-z_+-]*\ze.*')
+        if !empty(ft) && ft !~# '^\d*$' | let filetypes[ft] = 1 | endif
+    endfor
+    if !exists('b:mkd_known_filetypes')
+        let b:mkd_known_filetypes = {}
+    endif
+    if !exists('b:mkd_included_filetypes')
+        " set syntax file name included
+        let b:mkd_included_filetypes = {}
+    endif
+    if !a:force && (b:mkd_known_filetypes == filetypes || empty(filetypes))
+        return
+    endif
+
+    " Now we're ready to actually highlight the code blocks.
+    let startgroup = 'mkdCodeStart'
+    let endgroup = 'mkdCodeEnd'
+    for ft in keys(filetypes)
+        if a:force || !has_key(b:mkd_known_filetypes, ft)
+            if has_key(s:filetype_dict, ft)
+                let filetype = s:filetype_dict[ft]
+            else
+                let filetype = ft
+            endif
+            let group = 'mkdSnippet' . toupper(substitute(filetype, '[+-]', '_', 'g'))
+            if !has_key(b:mkd_included_filetypes, filetype)
+                let include = s:SyntaxInclude(filetype)
+                let b:mkd_included_filetypes[filetype] = 1
+            else
+                let include = '@' . toupper(filetype)
+            endif
+            let command_backtick = 'syntax region %s matchgroup=%s start="^\s*`\{3,}\s*%s.*$" matchgroup=%s end="\s*`\{3,}$" keepend contains=%s%s'
+            let command_tilde    = 'syntax region %s matchgroup=%s start="^\s*\~\{3,}\s*%s.*$" matchgroup=%s end="\s*\~\{3,}$" keepend contains=%s%s'
+            execute printf(command_backtick, group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
+            execute printf(command_tilde,    group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
+            execute printf('syntax cluster mkdNonListItem add=%s', group)
+
+            let b:mkd_known_filetypes[ft] = 1
+        endif
+    endfor
+endfunction
+
+function! s:SyntaxInclude(filetype)
+    " Include the syntax highlighting of another {filetype}.
+    let grouplistname = '@' . toupper(a:filetype)
+    " Unset the name of the current syntax while including the other syntax
+    " because some syntax scripts do nothing when "b:current_syntax" is set
+    if exists('b:current_syntax')
+        let syntax_save = b:current_syntax
+        unlet b:current_syntax
+    endif
+    try
+        execute 'syntax include' grouplistname 'syntax/' . a:filetype . '.vim'
+        execute 'syntax include' grouplistname 'after/syntax/' . a:filetype . '.vim'
+    catch /E484/
+        " Ignore missing scripts
+    endtry
+    " Restore the name of the current syntax
+    if exists('syntax_save')
+        let b:current_syntax = syntax_save
+    elseif exists('b:current_syntax')
+        unlet b:current_syntax
+    endif
+    return grouplistname
+endfunction
+
+
+function! s:MarkdownRefreshSyntax(force)
+    if &filetype =~# 'markdown' && line('$') > 1
+        call s:MarkdownHighlightSources(a:force)
+    endif
+endfunction
+
+function! s:MarkdownClearSyntaxVariables()
+    if &filetype =~# 'markdown'
+        unlet! b:mkd_included_filetypes
+    endif
+endfunction
+
+augroup Mkd
+    " These autocmd calling s:MarkdownRefreshSyntax need to be kept in sync with
+    " the autocmds calling s:MarkdownSetupFolding in after/ftplugin/markdown.vim.
+    autocmd! * <buffer>
+    autocmd BufWinEnter <buffer> call s:MarkdownRefreshSyntax(1)
+    autocmd BufUnload <buffer> call s:MarkdownClearSyntaxVariables()
+    autocmd BufWritePost <buffer> call s:MarkdownRefreshSyntax(0)
+    autocmd InsertEnter,InsertLeave <buffer> call s:MarkdownRefreshSyntax(0)
+    autocmd CursorHold,CursorHoldI <buffer> call s:MarkdownRefreshSyntax(0)
+augroup END
diff --git a/runtime/syntax/markdown.vim b/runtime/syntax/markdown.vim
index 17b61c2fa..96bfbc9a3 100644
--- a/runtime/syntax/markdown.vim
+++ b/runtime/syntax/markdown.vim
@@ -1,169 +1,184 @@
 " Vim syntax file
-" Language:     Markdown
-" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
-" Filenames:    *.markdown
-" Last Change:  2020 Jan 14
+" Language:	Markdown
+" Maintainer:	Ben Williams <benw@plasticboy.com>
+" URL:		http://plasticboy.com/markdown-vim-mode/
+" Remark:	Uses HTML syntax file
+" TODO: 	Handle stuff contained within stuff (e.g. headings within blockquotes)
 
-if exists("b:current_syntax")
-  finish
-endif
-
-if !exists('main_syntax')
-  let main_syntax = 'markdown'
-endif
 
-runtime! syntax/html.vim
-unlet! b:current_syntax
+" Read the HTML syntax to start with
+if v:version < 600
+  so <sfile>:p:h/html.vim
+else
+  runtime! syntax/html.vim
 
-if !exists('g:markdown_fenced_languages')
-  let g:markdown_fenced_languages = []
-endif
-let s:done_include = {}
-for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
-  if has_key(s:done_include, matchstr(s:type,'[^.]*'))
-    continue
-  endif
-  if s:type =~ '\.'
-    let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
+  if exists('b:current_syntax')
+    unlet b:current_syntax
   endif
-  exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
-  unlet! b:current_syntax
-  let s:done_include[matchstr(s:type,'[^.]*')] = 1
-endfor
-unlet! s:type
-unlet! s:done_include
-
-if !exists('g:markdown_minlines')
-  let g:markdown_minlines = 50
 endif
-execute 'syn sync minlines=' . g:markdown_minlines
-syn case ignore
-
-syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
-syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
-
-syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
-
-syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
-syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
-
-syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
-syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
-
-syn match markdownHeadingRule "^[=-]\+$" contained
-
-syn region markdownH1 matchgroup=markdownH1Delimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH2 matchgroup=markdownH2Delimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH3 matchgroup=markdownH3Delimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH4 matchgroup=markdownH4Delimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH5 matchgroup=markdownH5Delimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH6 matchgroup=markdownH6Delimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-
-syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
 
-syn region markdownCodeBlock start="    \|\t" end="$" contained
+if v:version < 600
+  syntax clear
+elseif exists('b:current_syntax')
+  finish
+endif
 
-" TODO: real nesting
-syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
-syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
+" don't use standard HiLink, it will not work with included syntax files
+if v:version < 508
+  command! -nargs=+ HtmlHiLink hi link <args>
+else
+  command! -nargs=+ HtmlHiLink hi def link <args>
+endif
 
-syn match markdownRule "\* *\* *\*[ *]*$" contained
-syn match markdownRule "- *- *-[ -]*$" contained
+syn spell toplevel
+syn case ignore
+syn sync linebreaks=1
 
-syn match markdownLineBreak " \{2,\}$"
+let s:conceal = ''
+let s:concealends = ''
+let s:concealcode = ''
+if has('conceal') && get(g:, 'vim_markdown_conceal', 1)
+  let s:conceal = ' conceal'
+  let s:concealends = ' concealends'
+endif
+if has('conceal') && get(g:, 'vim_markdown_conceal_code_blocks', 1)
+  let s:concealcode = ' concealends'
+endif
 
-syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
-syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
-syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
+" additions to HTML groups
+if get(g:, 'vim_markdown_emphasis_multiline', 1)
+    let s:oneline = ''
+else
+    let s:oneline = ' oneline'
+endif
+syn region mkdItalic matchgroup=mkdItalic start="\%(\*\|_\)"    end="\%(\*\|_\)"
+syn region mkdBold matchgroup=mkdBold start="\%(\*\*\|__\)"    end="\%(\*\*\|__\)"
+syn region mkdBoldItalic matchgroup=mkdBoldItalic start="\%(\*\*\*\|___\)"    end="\%(\*\*\*\|___\)"
+execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs\*\ze[^\\\*\t ]\%(\%([^*]\|\\\*\|\n\)*[^\\\*\t ]\)\?\*\_W" end="[^\\\*\t ]\zs\*\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
+execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs_\ze[^\\_\t ]" end="[^\\_\t ]\zs_\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
+execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs\*\*\ze\S" end="\S\zs\*\*" keepend contains=@Spell' . s:oneline . s:concealends
+execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs__\ze\S" end="\S\zs__" keepend contains=@Spell' . s:oneline . s:concealends
+execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs\*\*\*\ze\S" end="\S\zs\*\*\*" keepend contains=@Spell' . s:oneline . s:concealends
+execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs___\ze\S" end="\S\zs___" keepend contains=@Spell' . s:oneline . s:concealends
+
+" [link](URL) | [link][id] | [link][] | ![image](URL)
+syn region mkdFootnotes matchgroup=mkdDelimiter start="\[^"    end="\]"
+execute 'syn region mkdID matchgroup=mkdDelimiter    start="\["    end="\]" contained oneline' . s:conceal
+execute 'syn region mkdURL matchgroup=mkdDelimiter   start="("     end=")"  contained oneline' . s:conceal
+execute 'syn region mkdLink matchgroup=mkdDelimiter  start="\\\@<!!\?\[\ze[^]\n]*\n\?[^]\n]*\][[(]" end="\]" contains=@mkdNonListItem,@Spell nextgroup=mkdURL,mkdID skipwhite' . s:concealends
+
+" Autolink without angle brackets.
+" mkd  inline links:      protocol     optional  user:pass@  sub/domain                    .com, .co.uk, etc         optional port   path/querystring/hash fragment
+"                         ------------ _____________________ ----------------------------- _________________________ ----------------- __
+syn match   mkdInlineURL /https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*/
+
+" Autolink with parenthesis.
+syn region  mkdInlineURL matchgroup=mkdDelimiter start="(\(https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?[^] \t]*)\)\@=" end=")"
+
+" Autolink with angle brackets.
+syn region mkdInlineURL matchgroup=mkdDelimiter start="\\\@<!<\ze[a-z][a-z0-9,.-]\{1,22}:\/\/[^> ]*>" end=">"
+
+" Link definitions: [id]: URL (Optional Title)
+syn region mkdLinkDef matchgroup=mkdDelimiter   start="^ \{,3}\zs\[\^\@!" end="]:" oneline nextgroup=mkdLinkDefTarget skipwhite
+syn region mkdLinkDefTarget start="<\?\zs\S" excludenl end="\ze[>[:space:]\n]"   contained nextgroup=mkdLinkTitle,mkdLinkDef skipwhite skipnl oneline
+syn region mkdLinkTitle matchgroup=mkdDelimiter start=+"+     end=+"+  contained
+syn region mkdLinkTitle matchgroup=mkdDelimiter start=+'+     end=+'+  contained
+syn region mkdLinkTitle matchgroup=mkdDelimiter start=+(+     end=+)+  contained
+
+"HTML headings
+syn region htmlH1       matchgroup=mkdHeading     start="^\s*#"                   end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn region htmlH2       matchgroup=mkdHeading     start="^\s*##"                  end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn region htmlH3       matchgroup=mkdHeading     start="^\s*###"                 end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn region htmlH4       matchgroup=mkdHeading     start="^\s*####"                end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn region htmlH5       matchgroup=mkdHeading     start="^\s*#####"               end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn region htmlH6       matchgroup=mkdHeading     start="^\s*######"              end="$" contains=mkdLink,mkdInlineURL,@Spell
+syn match  htmlH1       /^.\+\n=\+$/ contains=mkdLink,mkdInlineURL,@Spell
+syn match  htmlH2       /^.\+\n-\+$/ contains=mkdLink,mkdInlineURL,@Spell
+
+"define Markdown groups
+syn match  mkdLineBreak    /  \+$/
+syn region mkdBlockquote   start=/^\s*>/                   end=/$/ contains=mkdLink,mkdInlineURL,mkdLineBreak,@Spell
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!`/                     end=/`/'  . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!``/ skip=/[^`]`[^`]/   end=/``/' . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(`\{3,}\)[^`]*$/                       end=/^\s*\z1`*\s*$/'            . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!\~\~/  end=/\(\([^\\]\|^\)\\\)\@<!\~\~/'               . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(\~\{3,}\)\s*[0-9A-Za-z_+-]*\s*$/      end=/^\s*\z1\~*\s*$/'           . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<pre\(\|\_s[^>]*\)\\\@<!>"                   end="</pre>"'                   . s:concealcode
+execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<code\(\|\_s[^>]*\)\\\@<!>"                  end="</code>"'                  . s:concealcode
+syn region mkdFootnote     start="\[^"                     end="\]"
+syn match  mkdCode         /^\s*\n\(\(\s\{8,}[^ ]\|\t\t\+[^\t]\).*\n\)\+/
+syn match  mkdCode         /\%^\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/
+syn match  mkdCode         /^\s*\n\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/ contained
+syn match  mkdListItem     /^\s*\%([-*+]\|\d\+\.\)\ze\s\+/ contained
+syn region mkdListItemLine start="^\s*\%([-*+]\|\d\+\.\)\s\+" end="$" oneline contains=@mkdNonListItem,mkdListItem,@Spell
+syn region mkdNonListItemBlock start="\(\%^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@!\|\n\(\_^\_$\|\s\{4,}[^ ]\|\t+[^\t]\)\@!\)" end="^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@=" contains=@mkdNonListItem,@Spell
+syn match  mkdRule         /^\s*\*\s\{0,1}\*\s\{0,1}\*\(\*\|\s\)*$/
+syn match  mkdRule         /^\s*-\s\{0,1}-\s\{0,1}-\(-\|\s\)*$/
+syn match  mkdRule         /^\s*_\s\{0,1}_\s\{0,1}_\(_\|\s\)*$/
+
+" YAML frontmatter
+if get(g:, 'vim_markdown_frontmatter', 0)
+  syn include @yamlTop syntax/yaml.vim
+  syn region Comment matchgroup=mkdDelimiter start="\%^---$" end="^\(---\|\.\.\.\)$" contains=@yamlTop keepend
+  unlet! b:current_syntax
+endif
 
-syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\%(\_[^][]\|\[\_[^][]*\]\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
-syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
-syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
-syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
+if get(g:, 'vim_markdown_toml_frontmatter', 0)
+  try
+    syn include @tomlTop syntax/toml.vim
+    syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$" transparent contains=@tomlTop keepend
+    unlet! b:current_syntax
+  catch /E484/
+    syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$"
+  endtry
+endif
 
-let s:concealends = ''
-if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
-  let s:concealends = ' concealends'
+if get(g:, 'vim_markdown_json_frontmatter', 0)
+  try
+    syn include @jsonTop syntax/json.vim
+    syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$" contains=@jsonTop keepend
+    unlet! b:current_syntax
+  catch /E484/
+    syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$"
+  endtry
 endif
-exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
-exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
-exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
-
-syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
-syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
-syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend
-
-syn match markdownFootnote "\[^[^\]]\+\]"
-syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
-
-if main_syntax ==# 'markdown'
-  let s:done_include = {}
-  for s:type in g:markdown_fenced_languages
-    if has_key(s:done_include, matchstr(s:type,'[^.]*'))
-      continue
-    endif
-    exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*````*\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*````*\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g') . s:concealends
-    let s:done_include[matchstr(s:type,'[^.]*')] = 1
-  endfor
-  unlet! s:type
-  unlet! s:done_include
+
+if get(g:, 'vim_markdown_math', 0)
+  syn include @tex syntax/tex.vim
+  syn region mkdMath start="\\\@<!\$" end="\$" skip="\\\$" contains=@tex keepend
+  syn region mkdMath start="\\\@<!\$\$" end="\$\$" skip="\\\$" contains=@tex keepend
 endif
 
-syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
-syn match markdownError "\w\@<=_\w\@="
-
-hi def link markdownH1                    htmlH1
-hi def link markdownH2                    htmlH2
-hi def link markdownH3                    htmlH3
-hi def link markdownH4                    htmlH4
-hi def link markdownH5                    htmlH5
-hi def link markdownH6                    htmlH6
-hi def link markdownHeadingRule           markdownRule
-hi def link markdownH1Delimiter           markdownHeadingDelimiter
-hi def link markdownH2Delimiter           markdownHeadingDelimiter
-hi def link markdownH3Delimiter           markdownHeadingDelimiter
-hi def link markdownH4Delimiter           markdownHeadingDelimiter
-hi def link markdownH5Delimiter           markdownHeadingDelimiter
-hi def link markdownH6Delimiter           markdownHeadingDelimiter
-hi def link markdownHeadingDelimiter      Delimiter
-hi def link markdownOrderedListMarker     markdownListMarker
-hi def link markdownListMarker            htmlTagName
-hi def link markdownBlockquote            Comment
-hi def link markdownRule                  PreProc
-
-hi def link markdownFootnote              Typedef
-hi def link markdownFootnoteDefinition    Typedef
-
-hi def link markdownLinkText              htmlLink
-hi def link markdownIdDeclaration         Typedef
-hi def link markdownId                    Type
-hi def link markdownAutomaticLink         markdownUrl
-hi def link markdownUrl                   Float
-hi def link markdownUrlTitle              String
-hi def link markdownIdDelimiter           markdownLinkDelimiter
-hi def link markdownUrlDelimiter          htmlTag
-hi def link markdownUrlTitleDelimiter     Delimiter
-
-hi def link markdownItalic                htmlItalic
-hi def link markdownItalicDelimiter       markdownItalic
-hi def link markdownBold                  htmlBold
-hi def link markdownBoldDelimiter         markdownBold
-hi def link markdownBoldItalic            htmlBoldItalic
-hi def link markdownBoldItalicDelimiter   markdownBoldItalic
-hi def link markdownCodeDelimiter         Delimiter
-
-hi def link markdownEscape                Special
-hi def link markdownError                 Error
-
-let b:current_syntax = "markdown"
-if main_syntax ==# 'markdown'
-  unlet main_syntax
+" Strike through
+if get(g:, 'vim_markdown_strikethrough', 0)
+    execute 'syn region mkdStrike matchgroup=htmlStrike start="\%(\~\~\)" end="\%(\~\~\)"' . s:concealends
+    HtmlHiLink mkdStrike        htmlStrike
 endif
 
-" vim:set sw=2:
+syn cluster mkdNonListItem contains=@htmlTop,htmlItalic,htmlBold,htmlBoldItalic,mkdFootnotes,mkdInlineURL,mkdLink,mkdLinkDef,mkdLineBreak,mkdBlockquote,mkdCode,mkdRule,htmlH1,htmlH2,htmlH3,htmlH4,htmlH5,htmlH6,mkdMath,mkdStrike
+
+"highlighting for Markdown groups
+HtmlHiLink mkdString        String
+HtmlHiLink mkdCode          String
+HtmlHiLink mkdCodeDelimiter String
+HtmlHiLink mkdCodeStart     String
+HtmlHiLink mkdCodeEnd       String
+HtmlHiLink mkdFootnote      Comment
+HtmlHiLink mkdBlockquote    Comment
+HtmlHiLink mkdListItem      Identifier
+HtmlHiLink mkdRule          Identifier
+HtmlHiLink mkdLineBreak     Visual
+HtmlHiLink mkdFootnotes     htmlLink
+HtmlHiLink mkdLink          htmlLink
+HtmlHiLink mkdURL           htmlString
+HtmlHiLink mkdInlineURL     htmlLink
+HtmlHiLink mkdID            Identifier
+HtmlHiLink mkdLinkDef       mkdID
+HtmlHiLink mkdLinkDefTarget mkdURL
+HtmlHiLink mkdLinkTitle     htmlString
+HtmlHiLink mkdDelimiter     Delimiter
+
+let b:current_syntax = 'mkd'
+
+delcommand HtmlHiLink
+" vim: ts=8
-- 
2.33.1

