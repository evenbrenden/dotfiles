From 3ef51c25fd8331a5982dd3d884fd951a3f4e5c2e Mon Sep 17 00:00:00 2001
From: Even Brenden <evenbrenden@gmail.com>
Date: Wed, 18 May 2022 09:58:18 +0200
Subject: [PATCH 1/1] Use Markdown files from vim-markdown-concealed

From prurigro/vim-markdown-concealed at 401f9d7.
---
 runtime/ftplugin/markdown.vim | 464 ++++++++++++++++++++++++++++++----
 runtime/syntax/markdown.vim   | 273 +++++++++-----------
 2 files changed, 523 insertions(+), 214 deletions(-)

diff --git a/runtime/ftplugin/markdown.vim b/runtime/ftplugin/markdown.vim
index fc1d9e068..23b0f8e6f 100644
--- a/runtime/ftplugin/markdown.vim
+++ b/runtime/ftplugin/markdown.vim
@@ -1,74 +1,430 @@
-" Vim filetype plugin
-" Language:		Markdown
-" Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
-" Last Change:		2019 Dec 05
+"TODO print messages when on visual mode. I only see VISUAL, not the messages.
 
-if exists("b:did_ftplugin")
-  finish
-endif
+" Function interface phylosophy:
+"
+" - functions take arbitrary line numbers as parameters.
+"    Current cursor line is only a suitable default parameter.
+"
+" - only functions that bind directly to user actions:
+"
+"    - print error messages.
+"       All intermediate functions limit themselves return `0` to indicate an error.
+"
+"    - move the cursor. All other functions do not move the cursor.
+"
+" This is how you should view headers:
+"
+"   |BUFFER
+"   |
+"   |Outside any header
+"   |
+" a-+# a
+"   |
+"   |Inside a
+"   |
+" a-+
+" b-+## b
+"   |
+"   |inside b
+"   |
+" b-+
+" c-+### c
+"   |
+"   |Inside c
+"   |
+" c-+
+" d-|# d
+"   |
+"   |Inside d
+"   |
+" d-+
+" e-|e
+"   |====
+"   |
+"   |Inside e
+"   |
+" e-+
 
-runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
+" For each level, contains the regexp that matches at that level only.
+let s:levelRegexpDict = {
+    \ 1: '\v^(#[^#]|.+\n\=+$)',
+    \ 2: '\v^(##[^#]|.+\n-+$)',
+    \ 3: '\v^###[^#]',
+    \ 4: '\v^####[^#]',
+    \ 5: '\v^#####[^#]',
+    \ 6: '\v^######[^#]'
+\ }
 
-setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
-setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
-setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:
+" Maches any header level of any type.
+"
+" This could be deduced from `s:levelRegexpDict`, but it is more
+" efficient to have a single regexp for this.
+"
+let s:headersRegexp = '\v^(#|.+\n(\=+|-+)$)'
 
-if exists('b:undo_ftplugin')
-  let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
-else
-  let b:undo_ftplugin = "setl cms< com< fo< flp<"
-endif
+" Returns the line number of the first header before `line`, called the
+" current header.
+"
+" If there is no current header, return `0`.
+"
+" @param a:1 The line to look the header of. Default value: `getpos('.')`.
+"
+function! s:Markdown_GetHeaderLineNum(...)
+    if a:0 == 0
+        let l:l = line('.')
+    else
+        let l:l = a:1
+    endif
+    while(l:l > 0)
+        if join(getline(l:l, l:l + 1), "\n") =~ s:headersRegexp
+            return l:l
+        endif
+        let l:l -= 1
+    endwhile
+    return 0
+endfunction
+
+" - if inside a header goes to it.
+"    Return its line number.
+"
+" - if on top level outside any headers,
+"    print a warning
+"    Return `0`.
+"
+function! s:Markdown_MoveToCurHeader()
+    let l:lineNum = s:Markdown_GetHeaderLineNum()
+    if l:lineNum != 0
+        call cursor(l:lineNum, 1)
+    else
+        echo 'outside any header'
+        "normal! gg
+    endif
+    return l:lineNum
+endfunction
+
+" Move cursor to next header of any level.
+"
+" If there are no more headers, print a warning.
+"
+function! s:Markdown_MoveToNextHeader()
+    if search(s:headersRegexp, 'W') == 0
+        "normal! G
+        echo 'no next header'
+    endif
+endfunction
 
-function! s:NotCodeBlock(lnum) abort
-  return synIDattr(synID(v:lnum, 1, 1), 'name') !=# 'markdownCode'
+" Move cursor to previous header (before current) of any level.
+"
+" If it does not exist, print a warning.
+"
+function! s:Markdown_MoveToPreviousHeader()
+    let l:curHeaderLineNumber = s:Markdown_GetHeaderLineNum()
+    let l:noPreviousHeader = 0
+    if l:curHeaderLineNumber <= 1
+        let l:noPreviousHeader = 1
+    else
+        let l:previousHeaderLineNumber = s:Markdown_GetHeaderLineNum(l:curHeaderLineNumber - 1)
+        if l:previousHeaderLineNumber == 0
+            let l:noPreviousHeader = 1
+        else
+            call cursor(l:previousHeaderLineNumber, 1)
+        endif
+    endif
+    if l:noPreviousHeader
+        echo 'no previous header'
+    endif
 endfunction
 
-function! MarkdownFold() abort
-  let line = getline(v:lnum)
+" - if line is inside a header, return the header level (h1 -> 1, h2 -> 2, etc.).
+"
+" - if line is at top level outside any headers, return `0`.
+"
+function! s:Markdown_GetHeaderLevel(...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:linenum = s:Markdown_GetHeaderLineNum(l:line)
+    if l:linenum != 0
+        return s:Markdown_GetLevelOfHeaderAtLine(l:linenum)
+    else
+        return 0
+    endif
+endfunction
+
+" Returns the level of the header at the given line.
+"
+" If there is no header at the given line, returns `0`.
+"
+function! s:Markdown_GetLevelOfHeaderAtLine(linenum)
+    let l:lines = join(getline(a:linenum, a:linenum + 1), "\n")
+    for l:key in keys(s:levelRegexpDict)
+        if l:lines =~ get(s:levelRegexpDict, l:key)
+            return l:key
+        endif
+    endfor
+    return 0
+endfunction
+
+" Move cursor to parent header of the current header.
+"
+" If it does not exit, print a warning and do nothing.
+"
+function! s:Markdown_MoveToParentHeader()
+    let l:linenum = s:Markdown_GetParentHeaderLineNumber()
+    if l:linenum != 0
+        call cursor(l:linenum, 1)
+    else
+        echo 'no parent header'
+    endif
+endfunction
+
+" Return the line number of the parent header of line `line`.
+"
+" If it has no parent, return `0`.
+"
+function! s:Markdown_GetParentHeaderLineNumber(...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:level = s:Markdown_GetHeaderLevel(l:line)
+    if l:level > 1
+        let l:linenum = s:Markdown_GetPreviousHeaderLineNumberAtLevel(l:level - 1, l:line)
+        return l:linenum
+    endif
+    return 0
+endfunction
 
-  if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
-    return ">" . match(line, ' ')
-  endif
+" Return the line number of the previous header of given level.
+" in relation to line `a:1`. If not given, `a:1 = getline()`
+"
+" `a:1` line is included, and this may return the current header.
+"
+" If none return 0.
+"
+function! s:Markdown_GetNextHeaderLineNumberAtLevel(level, ...)
+    if a:0 < 1
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:l = l:line
+    while(l:l <= line('$'))
+        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
+            return l:l
+        endif
+        let l:l += 1
+    endwhile
+    return 0
+endfunction
 
-  let nextline = getline(v:lnum + 1)
-  if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
-    return ">1"
-  endif
+" Return the line number of the previous header of given level.
+" in relation to line `a:1`. If not given, `a:1 = getline()`
+"
+" `a:1` line is included, and this may return the current header.
+"
+" If none return 0.
+"
+function! s:Markdown_GetPreviousHeaderLineNumberAtLevel(level, ...)
+    if a:0 == 0
+        let l:line = line('.')
+    else
+        let l:line = a:1
+    endif
+    let l:l = l:line
+    while(l:l > 0)
+        if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
+            return l:l
+        endif
+        let l:l -= 1
+    endwhile
+    return 0
+endfunction
 
-  if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
-    return ">2"
-  endif
+" Move cursor to next sibling header.
+"
+" If there is no next siblings, print a warning and don't move.
+"
+function! s:Markdown_MoveToNextSiblingHeader()
+    let l:curHeaderLineNumber = s:Markdown_GetHeaderLineNum()
+    let l:curHeaderLevel = s:Markdown_GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
+    let l:curHeaderParentLineNumber = s:Markdown_GetParentHeaderLineNumber()
+    let l:nextHeaderSameLevelLineNumber = s:Markdown_GetNextHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber + 1)
+    let l:noNextSibling = 0
+    if l:nextHeaderSameLevelLineNumber == 0
+        let l:noNextSibling = 1
+    else
+        let l:nextHeaderSameLevelParentLineNumber = s:Markdown_GetParentHeaderLineNumber(l:nextHeaderSameLevelLineNumber)
+        if l:curHeaderParentLineNumber == l:nextHeaderSameLevelParentLineNumber
+            call cursor(l:nextHeaderSameLevelLineNumber, 1)
+        else
+            let l:noNextSibling = 1
+        endif
+    endif
+    if l:noNextSibling
+        echo 'no next sibling header'
+    endif
+endfunction
 
-  return "="
+" Move cursor to previous sibling header.
+"
+" If there is no previous siblings, print a warning and do nothing.
+"
+function! s:Markdown_MoveToPreviousSiblingHeader()
+    let l:curHeaderLineNumber = s:Markdown_GetHeaderLineNum()
+    let l:curHeaderLevel = s:Markdown_GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
+    let l:curHeaderParentLineNumber = s:Markdown_GetParentHeaderLineNumber()
+    let l:previousHeaderSameLevelLineNumber = s:Markdown_GetPreviousHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber - 1)
+    let l:noPreviousSibling = 0
+    if l:previousHeaderSameLevelLineNumber == 0
+        let l:noPreviousSibling = 1
+    else
+        let l:previousHeaderSameLevelParentLineNumber = s:Markdown_GetParentHeaderLineNumber(l:previousHeaderSameLevelLineNumber)
+        if l:curHeaderParentLineNumber == l:previousHeaderSameLevelParentLineNumber
+            call cursor(l:previousHeaderSameLevelLineNumber, 1)
+        else
+            let l:noPreviousSibling = 1
+        endif
+    endif
+    if l:noPreviousSibling
+        echo 'no previous sibling header'
+    endif
 endfunction
 
-function! s:HashIndent(lnum) abort
-  let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
-  if len(hash_header)
-    return hash_header
-  else
-    let nextline = getline(a:lnum + 1)
-    if nextline =~# '^=\+\s*$'
-      return '#'
-    elseif nextline =~# '^-\+\s*$'
-      return '##'
+function! s:Markdown_Toc(...)
+    if a:0 > 0
+        let l:window_type = a:1
+    else
+        let l:window_type = 'vertical'
     endif
-  endif
+
+    try
+        silent lvimgrep /\(^\S.*\(\n[=-]\+\n\)\@=\|^#\+\)/ %
+    catch /E480/
+        echom "Toc: No headers."
+        return
+    endtry
+
+    if l:window_type ==# 'horizontal'
+        lopen
+    elseif l:window_type ==# 'vertical'
+        vertical lopen
+        let &winwidth=(&columns/2)
+    elseif l:window_type ==# 'tab'
+        tab lopen
+    else
+        lopen
+    endif
+    set modifiable
+    %s/\v^([^|]*\|){2,2} #//
+    for i in range(1, line('$'))
+        " this is the quickfix data for the current item
+        let d = getqflist()[i-1]
+        " atx headers
+        if match(d.text, "^#") > -1
+            let l:level = len(matchstr(d.text, '#*', 'g'))-1
+            let d.text = substitute(d.text, '\v^#*[ ]*', '', '')
+            let d.text = substitute(d.text, '\v[ ]*#*$', '', '')
+        " setex headers
+        else
+            let l:next_line = getbufline(bufname(d.bufnr), d.lnum+1)
+            if match(l:next_line, "=") > -1
+                let l:level = 0
+            elseif match(l:next_line, "-") > -1
+                let l:level = 1
+            endif
+        endif
+        call setline(i, repeat('  ', l:level). d.text)
+    endfor
+    set nomodified
+    set nomodifiable
+    normal! gg
+endfunction
+
+" Wrapper to do move commands in visual mode.
+"
+function! s:VisMove(f)
+    norm! gv
+    call function(a:f)()
 endfunction
 
-function! MarkdownFoldText() abort
-  let hash_indent = s:HashIndent(v:foldstart)
-  let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
-  let foldsize = (v:foldend - v:foldstart + 1)
-  let linecount = '['.foldsize.' lines]'
-  return hash_indent.' '.title.' '.linecount
+" Map in both normal and visual modes.
+"
+function! s:MapNormVis(rhs,lhs)
+    execute 'nn <buffer><silent> ' . a:rhs . ' :call ' . a:lhs . '()<cr>'
+    execute 'vn <buffer><silent> ' . a:rhs . ' <esc>:call <sid>VisMove(''' . a:lhs . ''')<cr>'
 endfunction
 
-if has("folding") && exists("g:markdown_folding")
-  setlocal foldexpr=MarkdownFold()
-  setlocal foldmethod=expr
-  setlocal foldtext=MarkdownFoldText()
-  let b:undo_ftplugin .= " foldexpr< foldmethod< foldtext<"
+" Convert Setex headers in range `line1 .. line2` to Atx.
+" Returns the number of conversions.
+function! s:SetexToAtx(line1, line2)
+    let l:originalNumLines = line('$')
+    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n\=+$/# \1/'
+    execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n-+$/## \1/'
+    return l:originalNumLines - line('$')
+endfunction
+
+" If `a:1` is 0, decrease the level of all headers in range `line1 .. line2`.
+" Otherwise, increase the level. `a:1` defaults to `0`.
+function! s:HeaderDecrease(line1, line2, ...)
+    if a:0 > 0
+        let l:increase = a:1
+    else
+        let l:increase = 0
+    endif
+    if l:increase
+        let l:forbiddenLevel = 6
+        let l:replaceLevels = [5, 1]
+        let l:levelDelta = 1
+    else
+        let l:forbiddenLevel = 1
+        let l:replaceLevels = [2, 6]
+        let l:levelDelta = -1
+    endif
+    for l:line in range(a:line1, a:line2)
+        if join(getline(l:line, l:line + 1), "\n") =~ s:levelRegexpDict[l:forbiddenLevel]
+            echomsg 'There is an h' . l:forbiddenLevel . ' at line ' . l:line . '. Aborting.'
+            return
+        endif
+    endfor
+    let l:numSubstitutions = s:SetexToAtx(a:line1, a:line2)
+    for l:level in range(replaceLevels[0], replaceLevels[1], -l:levelDelta)
+        execute 'silent! ' . a:line1 . ',' . (a:line2 - l:numSubstitutions) . 'substitute/' . s:levelRegexpDict[l:level] . '/' . repeat('#', l:level + l:levelDelta) . '\1/g'
+    endfor
+endfunction
+
+call <sid>MapNormVis('<Plug>(Markdown_MoveToNextHeader)', '<sid>Markdown_MoveToNextHeader')
+call <sid>MapNormVis('<Plug>(Markdown_MoveToPreviousHeader)', '<sid>Markdown_MoveToPreviousHeader')
+call <sid>MapNormVis('<Plug>(Markdown_MoveToNextSiblingHeader)', '<sid>Markdown_MoveToNextSiblingHeader')
+call <sid>MapNormVis('<Plug>(Markdown_MoveToPreviousSiblingHeader)', '<sid>Markdown_MoveToPreviousSiblingHeader')
+" Menmonic: Up
+call <sid>MapNormVis('<Plug>(Markdown_MoveToParentHeader)', '<sid>Markdown_MoveToParentHeader')
+" Menmonic: Current
+call <sid>MapNormVis('<Plug>(Markdown_MoveToCurHeader)', '<sid>Markdown_MoveToCurHeader')
+
+if !get(g:, 'vim_markdown_no_default_key_mappings', 0)
+    nmap <buffer> ]] <Plug>(Markdown_MoveToNextHeader)
+    nmap <buffer> [[ <Plug>(Markdown_MoveToPreviousHeader)
+    nmap <buffer> ][ <Plug>(Markdown_MoveToNextSiblingHeader)
+    nmap <buffer> [] <Plug>(Markdown_MoveToPreviousSiblingHeader)
+    nmap <buffer> ]u <Plug>(Markdown_MoveToParentHeader)
+    nmap <buffer> ]c <Plug>(Markdown_MoveToCurHeader)
+
+    vmap <buffer> ]] <Plug>(Markdown_MoveToNextHeader)
+    vmap <buffer> [[ <Plug>(Markdown_MoveToPreviousHeader)
+    vmap <buffer> ][ <Plug>(Markdown_MoveToNextSiblingHeader)
+    vmap <buffer> [] <Plug>(Markdown_MoveToPreviousSiblingHeader)
+    vmap <buffer> ]u <Plug>(Markdown_MoveToParentHeader)
+    vmap <buffer> ]c <Plug>(Markdown_MoveToCurHeader)
 endif
 
-" vim:set sw=2:
+command! -buffer -range=% HeaderDecrease call s:HeaderDecrease(<line1>, <line2>)
+command! -buffer -range=% HeaderIncrease call s:HeaderDecrease(<line1>, <line2>, 1)
+command! -buffer -range=% SetexToAtx call s:SetexToAtx(<line1>, <line2>)
+command! -buffer Toc call s:Markdown_Toc()
+command! -buffer Toch call s:Markdown_Toc('horizontal')
+command! -buffer Tocv call s:Markdown_Toc('vertical')
+command! -buffer Toct call s:Markdown_Toc('tab')
diff --git a/runtime/syntax/markdown.vim b/runtime/syntax/markdown.vim
index 17b61c2fa..db3e46980 100644
--- a/runtime/syntax/markdown.vim
+++ b/runtime/syntax/markdown.vim
@@ -1,169 +1,122 @@
 " Vim syntax file
-" Language:     Markdown
-" Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
-" Filenames:    *.markdown
-" Last Change:  2020 Jan 14
-
-if exists("b:current_syntax")
-  finish
+"
+" Language: Markdown Concealed Vim Syntax
+" Based_On: vim-markdown v9: https://github.com/plasticboy/vim-markdown
+" Original_Author: Ben Williams <benw@plasticboy.com>
+" Conceal_Mods_and_General_Improvements: Kevin MacMartin <prurigro at gmail dot com>
+"
+
+" Read the HTML syntax to start with
+if version < 600
+    so <sfile>:p:h/html.vim
+else
+    runtime! syntax/html.vim
+    if exists('b:current_syntax')
+        unlet b:current_syntax
+    endif
 endif
 
-if !exists('main_syntax')
-  let main_syntax = 'markdown'
+if version < 600
+    syntax clear
+elseif exists("b:current_syntax")
+    finish
 endif
 
-runtime! syntax/html.vim
-unlet! b:current_syntax
-
-if !exists('g:markdown_fenced_languages')
-  let g:markdown_fenced_languages = []
+" don't use standard HiLink, it will not work with included syntax files
+if version < 508|command! -nargs=+ HtmlHiLink hi link <args>|else|command! -nargs=+ HtmlHiLink hi def link <args>|endif
+    command! -nargs=+ HtmlHiLink hi link <args>
+else|command! -nargs=+ HtmlHiLink hi def link <args>|endif
+    command! -nargs=+ HtmlHiLink hi def link <args>
 endif
-let s:done_include = {}
-for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
-  if has_key(s:done_include, matchstr(s:type,'[^.]*'))
-    continue
-  endif
-  if s:type =~ '\.'
-    let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
-  endif
-  exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
-  unlet! b:current_syntax
-  let s:done_include[matchstr(s:type,'[^.]*')] = 1
-endfor
-unlet! s:type
-unlet! s:done_include
 
-if !exists('g:markdown_minlines')
-  let g:markdown_minlines = 50
-endif
-execute 'syn sync minlines=' . g:markdown_minlines
+syn spell toplevel
 syn case ignore
-
-syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
-syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
-
-syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
-
-syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
-syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
-
-syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
-syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
-
-syn match markdownHeadingRule "^[=-]\+$" contained
-
-syn region markdownH1 matchgroup=markdownH1Delimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH2 matchgroup=markdownH2Delimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH3 matchgroup=markdownH3Delimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH4 matchgroup=markdownH4Delimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH5 matchgroup=markdownH5Delimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-syn region markdownH6 matchgroup=markdownH6Delimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
-
-syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
-
-syn region markdownCodeBlock start="    \|\t" end="$" contained
-
-" TODO: real nesting
-syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
-syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
-
-syn match markdownRule "\* *\* *\*[ *]*$" contained
-syn match markdownRule "- *- *-[ -]*$" contained
-
-syn match markdownLineBreak " \{2,\}$"
-
-syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
-syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
-syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
-syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
-
-syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\%(\_[^][]\|\[\_[^][]*\]\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
-syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
-syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
-syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
-
-let s:concealends = ''
-if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
-  let s:concealends = ' concealends'
-endif
-exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
-exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
-exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
-exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
-
-syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
-syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
-syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend
-
-syn match markdownFootnote "\[^[^\]]\+\]"
-syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
-
-if main_syntax ==# 'markdown'
-  let s:done_include = {}
-  for s:type in g:markdown_fenced_languages
-    if has_key(s:done_include, matchstr(s:type,'[^.]*'))
-      continue
-    endif
-    exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*````*\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*````*\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g') . s:concealends
-    let s:done_include[matchstr(s:type,'[^.]*')] = 1
-  endfor
-  unlet! s:type
-  unlet! s:done_include
-endif
-
-syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
-syn match markdownError "\w\@<=_\w\@="
-
-hi def link markdownH1                    htmlH1
-hi def link markdownH2                    htmlH2
-hi def link markdownH3                    htmlH3
-hi def link markdownH4                    htmlH4
-hi def link markdownH5                    htmlH5
-hi def link markdownH6                    htmlH6
-hi def link markdownHeadingRule           markdownRule
-hi def link markdownH1Delimiter           markdownHeadingDelimiter
-hi def link markdownH2Delimiter           markdownHeadingDelimiter
-hi def link markdownH3Delimiter           markdownHeadingDelimiter
-hi def link markdownH4Delimiter           markdownHeadingDelimiter
-hi def link markdownH5Delimiter           markdownHeadingDelimiter
-hi def link markdownH6Delimiter           markdownHeadingDelimiter
-hi def link markdownHeadingDelimiter      Delimiter
-hi def link markdownOrderedListMarker     markdownListMarker
-hi def link markdownListMarker            htmlTagName
-hi def link markdownBlockquote            Comment
-hi def link markdownRule                  PreProc
-
-hi def link markdownFootnote              Typedef
-hi def link markdownFootnoteDefinition    Typedef
-
-hi def link markdownLinkText              htmlLink
-hi def link markdownIdDeclaration         Typedef
-hi def link markdownId                    Type
-hi def link markdownAutomaticLink         markdownUrl
-hi def link markdownUrl                   Float
-hi def link markdownUrlTitle              String
-hi def link markdownIdDelimiter           markdownLinkDelimiter
-hi def link markdownUrlDelimiter          htmlTag
-hi def link markdownUrlTitleDelimiter     Delimiter
-
-hi def link markdownItalic                htmlItalic
-hi def link markdownItalicDelimiter       markdownItalic
-hi def link markdownBold                  htmlBold
-hi def link markdownBoldDelimiter         markdownBold
-hi def link markdownBoldItalic            htmlBoldItalic
-hi def link markdownBoldItalicDelimiter   markdownBoldItalic
-hi def link markdownCodeDelimiter         Delimiter
-
-hi def link markdownEscape                Special
-hi def link markdownError                 Error
-
+syn sync linebreaks=1
+
+"additions to HTML groups
+syn region htmlItalic          matchgroup=mkdDelimiter start="\\\@<!\*\S\@="                          end="\S\@<=\\\@<!\*"                   keepend oneline concealends contains=mkdEscape
+syn region htmlItalic          matchgroup=mkdDelimiter start="\(^\|\s\)\@<=_\|\\\@<!_\([^_]\+\s\)\@=" end="\S\@<=_\|_\S\@="                  keepend oneline concealends contains=mkdEscape
+syn region htmlBold            matchgroup=mkdDelimiter start="\S\@<=\*\*\|\*\*\S\@="                  end="\S\@<=\*\*\|\*\*\S\@="            keepend oneline concealends contains=mkdEscape
+syn region htmlBold            matchgroup=mkdDelimiter start="\S\@<=__\|__\S\@="                      end="\S\@<=__\|__\S\@="                keepend oneline concealends contains=mkdEscape
+syn region htmlBoldItalic      matchgroup=mkdDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@="              end="\S\@<=\*\*\*\|\*\*\*\S\@="        keepend oneline concealends contains=mkdEscape
+syn region htmlBoldItalic      matchgroup=mkdDelimiter start="\S\@<=___\|___\S\@="                    end="\S\@<=___\|___\S\@="              keepend oneline concealends contains=mkdEscape
+syn region mkdFootnotes        matchgroup=mkdDelimiter start="\[^"                                    end="\]"
+syn region mkdID               matchgroup=mkdDelimiter start="\!?\["                                  end="\]"                               contained oneline
+syn region mkdURL              matchgroup=mkdDelimiter start="("                                      end=")"                                contained contains=mkdEscape,mkdURLInnerParen oneline
+syn match  mkdURLInnerParen                            "([^)]*)"                                                                             contained
+syn region mkdLink             matchgroup=mkdDelimiter start="\\\@<!\["                               end="\]\ze\s*[[(]"                     contains=@Spell,mkdEscape nextgroup=mkdURL,mkdID skipwhite oneline concealends cchar=→
+syn match  mkdInlineURL                                /https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?\S*/
+syn region mkdLinkDef          matchgroup=mkdDelimiter start="^ \{,3}\zs\["                           end="]:"                               oneline nextgroup=mkdLinkDefTarget skipwhite
+syn region mkdLinkDefTarget                            start="<\?\zs\S" excludenl                     end="\ze[>[:space:]\n]"                contained nextgroup=mkdLinkTitle,mkdLinkDef skipwhite skipnl oneline
+syn region mkdLinkTitle        matchgroup=mkdDelimiter start=+"+                                      end=+"+                                contained
+syn region mkdLinkTitle        matchgroup=mkdDelimiter start=+'+                                      end=+'+                                contained
+syn region mkdLinkTitle        matchgroup=mkdDelimiter start=+(+                                      end=+)+                                contained
+
+"define Markdown groups
+syn match  mkdLineContinue                             ".$"                                                                                  contained
+syn match  mkdLineBreak                                /  \+$/
+syn region mkdBlockquote                               start=/^\s*>/                                  end=/$/                                contains=mkdLineBreak,mkdLineContinue,@Spell
+syn region mkdCode             matchgroup=mkdDelimiter start=/\(\([^\\]\|^\)\\\)\@<!`/                end=/\(\([^\\]\|^\)\\\)\@<!`/          concealends
+syn region mkdCode             matchgroup=mkdDelimiter start=/\s*``[^`]*/                             end=/[^`]*``\s*/                       concealends
+syn region mkdCode             matchgroup=mkdDelimiter start=/^\s*```.*$/                             end=/^\s*```\s*$/                      concealends contains=mkdCodeCfg
+syn match  mkdCodeCfg                                  "{[^}]*}"                                                                             contained conceal
+syn region mkdCode             matchgroup=mkdDelimiter start="<pre[^>\\]*>"                           end="</pre>"                           concealends
+syn region mkdCode             matchgroup=mkdDelimiter start="<code[^>\\]*>"                          end="</code>"                          concealends
+syn region mkdFootnote         matchgroup=mkdDelimiter start="\[^"                                    end="\]"
+syn match  mkdCode                                     /^\s*\n\(\(\s\{8,}[^ ]\|\t\t\+[^\t]\).*\n\)\+/
+syn match  mkdIndentCode                               /^\s*\n\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/                                          contained
+syn match  mkdListItem                                 "^\s*[-*+]\s\+"                                                                       contains=mkdListTab,mkdListBullet2
+syn match  mkdListItem                                 "^\s*\d\+\.\s\+"                                                                      contains=mkdListTab
+syn match  mkdListTab                                  "^\s*\*"                                                                              contained contains=mkdListBullet1
+syn match  mkdListBullet1                              "\*"                                                                                  contained conceal cchar=•
+syn match  mkdListBullet2                              "[-*+]"                                                                               contained conceal cchar=•
+syn region mkdNonListItemBlock                         start="\n\(\_^\_$\|\s\{4,}[^ ]\|\t+[^\t]\)\@!" end="^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@=" contains=@mkdNonListItem,@Spell
+syn match  mkdRule                                     /^\s*\*\s\{0,1}\*\s\{0,1}\*$/
+syn match  mkdRule                                     /^\s*-\s\{0,1}-\s\{0,1}-$/
+syn match  mkdRule                                     /^\s*_\s\{0,1}_\s\{0,1}_$/
+syn match  mkdRule                                     /^\s*-\{3,}$/
+syn match  mkdRule                                     /^\s*\*\{3,5}$/
+
+" HTML headings
+syn region htmlH1              matchgroup=mkdDelimiter start="^\s*#"                                  end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn region htmlH2              matchgroup=mkdDelimiter start="^\s*##"                                 end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn region htmlH3              matchgroup=mkdDelimiter start="^\s*###"                                end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn region htmlH4              matchgroup=mkdDelimiter start="^\s*####"                               end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn region htmlH5              matchgroup=mkdDelimiter start="^\s*#####"                              end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn region htmlH6              matchgroup=mkdDelimiter start="^\s*######"                             end="\($\|[^\\]#\+\)"                  concealends contains=@Spell,mkdEscapeChar
+syn match  htmlH1                                      /^.\+\n=\+$/                                                                          contains=@Spell
+syn match  htmlH2                                      /^.\+\n-\+$/                                                                          contains=@Spell
+syn match  mkdEscape                                   "\\[`\*_{}\[\]()#\+-\.\!]"                                                            contained contains=mkdEscapeChar
+syn match  mkdEscapeChar                               "\\"                                                                                  contained conceal
+
+syn cluster mkdNonListItem contains=htmlItalic,htmlBold,htmlBoldItalic,mkdFootnotes,mkdID,mkdLink,mkdLinkDef,mkdLineBreak,mkdBlockquote,mkdCode,mkdIndentCode,mkdListItem,mkdRule,htmlH1,htmlH2,htmlH3,htmlH4,htmlH5,htmlH6,mkdEscape
+
+" Highlighting for Markdown groups
+HtmlHiLink mkdString        String
+HtmlHiLink mkdCode          String
+HtmlHiLink mkdIndentCode    String
+HtmlHiLink mkdEscape        Comment
+HtmlHiLink mkdEscapeChar    Comment
+HtmlHiLink mkdFootnote      Comment
+HtmlHiLink mkdBlockquote    Comment
+HtmlHiLink mkdLineContinue  Comment
+HtmlHiLink mkdDelimiter     Comment
+HtmlHiLink mkdListItem      Identifier
+HtmlHiLink mkdRule          Identifier
+HtmlHiLink mkdLineBreak     Todo
+HtmlHiLink mkdFootnotes     htmlLink
+HtmlHiLink mkdLink          htmlLink
+HtmlHiLink mkdURL           htmlString
+HtmlHiLink mkdURLInnerParen mkdURL
+HtmlHiLink mkdInlineURL     htmlLink
+HtmlHiLink mkdID            Identifier
+HtmlHiLink mkdLinkDef       mkdID
+HtmlHiLink mkdLinkDefTarget mkdURL
+HtmlHiLink mkdLinkTitle     htmlString
+HtmlHiLink mkdDelimiter     Delimiter
+
+setlocal formatoptions+=r "Automatically insert bullets
+setlocal formatoptions-=c "Do not automatically insert bullets when auto-wrapping with text-width
+setlocal comments=b:*,b:+,b:- "Accept various markers as bullets
 let b:current_syntax = "markdown"
-if main_syntax ==# 'markdown'
-  unlet main_syntax
-endif
-
-" vim:set sw=2:
+delcommand HtmlHiLink
-- 
2.33.1

